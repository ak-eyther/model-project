â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   MEMORY LEAK DEBUGGING TOOLKIT SUMMARY                      â•‘
â•‘                      Python/FastAPI Production Guide                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“¦ COMPLETE TOOLKIT DELIVERED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. MEMORY_DEBUGGING_START_HERE.md (12KB)
   â”œâ”€ Quick start guide (5 minutes to first leak detection)
   â”œâ”€ Decision tree for leak assessment
   â”œâ”€ Copy-paste fixes for 4 common patterns
   â”œâ”€ File navigation map
   â””â”€ Troubleshooting guide

2. MEMORY_LEAK_DEBUGGING_GUIDE.md (27KB) - COMPREHENSIVE REFERENCE
   â”œâ”€ Part 1: Tool Setup (8 tools with installation)
   â”œâ”€ Part 2: 5-Phase Workflow (10-100+ minute resolution)
   â”œâ”€ Part 3: Common Leak Patterns (7 types with fixes)
   â”œâ”€ Part 4: Real-World Debugging Checklist
   â”œâ”€ Part 5: Code Pattern Reference (GOOD vs BAD examples)
   â”œâ”€ Part 6: Quick Reference Commands
   â”œâ”€ Part 7: Regex Patterns for Log Analysis
   â”œâ”€ Part 8: Deployment Strategy
   â””â”€ Part 9: Summary Table

3. memory_debug_toolkit.py (17KB) - CLI TOOL
   â”œâ”€ Command 1: detect [duration_sec] [interval_sec]
   â”‚  â””â”€ Quick leak confirmation (RSS growth analysis)
   â”œâ”€ Command 2: track-objects
   â”‚  â””â”€ Show which object types are accumulating
   â”œâ”€ Command 3: scan-code [directory]
   â”‚  â””â”€ Pattern match for 8 memory leak patterns
   â”œâ”€ Command 4: analyze-logs [log_file]
   â”‚  â””â”€ Extract memory metrics from logs
   â””â”€ Command 5: dashboard [duration_sec] [interval_sec]
      â””â”€ Real-time memory monitoring dashboard

4. fastapi_memory_monitor.py (16KB) - INTEGRATION MODULE
   â”œâ”€ Drop-in FastAPI integration (1 line: setup_memory_monitoring(app))
   â”œâ”€ 7 Debug Endpoints:
   â”‚  â”œâ”€ GET /api/debug/memory/snapshot        (Current state + top allocations)
   â”‚  â”œâ”€ GET /api/debug/memory/growth          (Object type accumulation)
   â”‚  â”œâ”€ GET /api/debug/memory/history         (Memory over past N minutes)
   â”‚  â”œâ”€ GET /api/debug/memory/gc-stats        (Garbage collection stats)
   â”‚  â”œâ”€ POST /api/debug/memory/gc-collect     (Manual GC trigger)
   â”‚  â”œâ”€ GET /api/debug/memory/leaks           (Leak detection verdict)
   â”‚  â””â”€ GET /api/debug/memory/process-info    (Process details)
   â”œâ”€ Prometheus Metrics Integration
   â”œâ”€ @memory_tracked Decorator
   â””â”€ Background Metrics Collection

5. OBSERVABILITY_METRICS.md (11KB) - PRODUCTION MONITORING
   â”œâ”€ Critical Metrics:
   â”‚  â”œâ”€ RSS Growth Rate (leak detection)
   â”‚  â”œâ”€ Endpoint Memory Delta (hotspot identification)
   â”‚  â”œâ”€ Garbage Collection Metrics (GC slowdown indicator)
   â”‚  â””â”€ Object Growth Signals (leak source identification)
   â”œâ”€ Prometheus Setup (config examples)
   â”œâ”€ Grafana Dashboard (JSON template)
   â”œâ”€ Docker Compose Stack
   â”œâ”€ Kubernetes Deployment
   â”œâ”€ Alert Rules (tiered by severity)
   â”œâ”€ Example Queries
   â””â”€ Integration Checklist

6. MEMORY_LEAK_QUICK_REFERENCE.md (8KB) - CHEAT SHEET
   â”œâ”€ 60-Second Leak Detection
   â”œâ”€ 5-Phase Summary (with time estimates)
   â”œâ”€ Common Patterns & Fixes (copy-paste ready)
   â”œâ”€ Production Commands (no code changes)
   â”œâ”€ Alert Thresholds (tuned baseline values)
   â”œâ”€ Decision Tree (flowchart)
   â”œâ”€ Testing Your Fix (verification checklist)
   â”œâ”€ Common Mistakes (what to avoid)
   â””â”€ Terminal Commands Cheat Sheet

7. TOOLKIT_SUMMARY.txt - THIS FILE


ğŸ¯ WORKFLOW PHASES & TIMING
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Phase 1: CONFIRM LEAK (5 min)
  â””â”€ Command: python memory_debug_toolkit.py detect 300 10
     Output: Is leak real? Severity level? Growth rate?

Phase 2: FIND ENDPOINT (10 min)
  â””â”€ Add @memory_tracked to suspect endpoints
     Load test with vegeta/wrk
     Identify highest memory delta

Phase 3: PATTERN MATCH (10 min)
  â””â”€ Command: python memory_debug_toolkit.py scan-code ./app
     Output: Pattern names + recommended fixes

Phase 4: LINE-LEVEL DEBUG (20 min)
  â””â”€ Add @profile decorator
     Run: python -m memory_profiler app.py
     Identify exact allocation line

Phase 5: DEPLOY FIX (5 min setup + 30 min verify)
  â””â”€ Apply pattern-specific fix
     Load test 30 minutes
     Monitor <1MB/min growth
     Verify in Prometheus for 1 hour


ğŸ“Š MEMORY LEAK PATTERNS COVERED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. UNBOUNDED CACHE
   Pattern:     cache[key] = value (no cleanup)
   Severity:    HIGH
   Fix:         Use cachetools.TTLCache(maxsize=100, ttl=timedelta(hours=1))
   Example:     results_cache = {url: expensive_result}

2. GLOBAL ACCUMULATION
   Pattern:     GLOBAL_LIST = [] / GLOBAL_DICT = {}
   Severity:    HIGH
   Fix:         Use deque(maxlen=1000) or reset periodically
   Example:     RESULTS = [] # Always grows

3. CIRCULAR REFERENCES
   Pattern:     self.ref = self / parent.child = child.parent = parent
   Severity:    MEDIUM
   Fix:         Use weakref.ref() for circular references
   Example:     obj.reference = obj (GC can't clean up)

4. DATABASE CONNECTIONS
   Pattern:     conn = db.connect() (outside context manager)
   Severity:    HIGH
   Fix:         Use `async with db.connect() as conn:`
   Example:     session = Session() / conn.close() never called

5. EVENT LISTENERS
   Pattern:     .subscribe() / .addEventListener() (no unsubscribe)
   Severity:    HIGH
   Fix:         Store handler ID, call unsubscribe() in cleanup
   Example:     broker.subscribe("topic", callback) # Never unsubscribed

6. THREAD POOLS
   Pattern:     ThreadPoolExecutor() (no shutdown)
   Severity:    MEDIUM
   Fix:         Use `with ThreadPoolExecutor() as executor:` or .shutdown()
   Example:     executor = ThreadPoolExecutor() # Never shutdown

7. ASYNC TASKS
   Pattern:     asyncio.create_task() (not awaited)
   Severity:    MEDIUM
   Fix:         Always await or store handles for cancellation
   Example:     asyncio.create_task(coro) # Never awaited

8. FILE HANDLES
   Pattern:     open() (outside context manager)
   Severity:    MEDIUM
   Fix:         Use `with open(...) as f:`
   Example:     f = open(filename) # Never closed


ğŸ”§ TOOL USAGE EXAMPLES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

# Quick leak detection (5 min)
$ python memory_debug_toolkit.py detect 300 10
Output:
  ============================================================
  MEMORY LEAK DETECTION REPORT
  ============================================================
  Initial RSS:        512.5 MB
  Final RSS:          768.2 MB
  Total Growth:       255.7 MB
  Growth Rate:        51.14 MB/min
  Duration:           300 seconds
  Verdict:            LEAK DETECTED
  Severity:           CRITICAL
  ============================================================

# Scan codebase for patterns
$ python memory_debug_toolkit.py scan-code ./app
Output:
  ğŸŸ  HIGH SEVERITY (5 issues)

  ğŸ“ app/cache.py:42
     Pattern: unbounded_cache
     Issue: Cache grows without cleanup
     Code: self.cache[key] = expensive_result
     Fix: Add TTL (cachetools.TTLCache) or max size limit

# Track object growth
$ python memory_debug_toolkit.py track-objects
Output:
  ============================================================
  OBJECT GROWTH ANALYSIS
  ============================================================
  Type              Current    Baseline      Delta    Growth %
  dict                45678      10000     35678       356.8%  â† LEAK!
  list                12345       8000      4345        54.3%
  str                 98765      95000      3765         4.0%

# Real-time dashboard
$ python memory_debug_toolkit.py dashboard 600 5
Output:
  Memory Dashboard (updating every 5s for 600s)
  Time                 RSS MB        VMS MB      % Memory   # Threads
  14:32:45          512.5         1024.3        25.6%         8
  14:32:50          514.2         1024.5        25.7%         8
  14:32:55          516.8         1025.1        25.8%         8  â† GROWING


ğŸ“ˆ PROMETHEUS QUERIES FOR LEAK DETECTION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

# Detect linear growth >50MB/hour
rate(process_rss_bytes[1h]) > 52428800

# Detect spikes (>100MB in 5 min)
(process_rss_bytes - process_rss_bytes offset 5m) > 104857600

# Find high-memory endpoints
topk(10, rate(endpoint_memory_delta_bytes_sum[5m]))

# GC slowdown (collections taking >500ms)
histogram_quantile(0.95, gc_duration_ms) > 500


âœ… SETUP CHECKLIST
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Development/Staging:
  â–¡ pip install memory-profiler pympler objgraph psutil
  â–¡ python memory_debug_toolkit.py detect 300 10 (verify setup)
  â–¡ python memory_debug_toolkit.py scan-code ./app (find patterns)
  â–¡ Add setup_memory_monitoring(app) to FastAPI main.py
  â–¡ Access debug endpoints at /api/debug/memory/*

Production Monitoring:
  â–¡ pip install prometheus-client (already in monitor.py)
  â–¡ Configure Prometheus to scrape :8001/metrics
  â–¡ Import Grafana dashboard JSON (in OBSERVABILITY_METRICS.md)
  â–¡ Create alert rules for high/critical thresholds
  â–¡ Setup PagerDuty/Slack integration
  â–¡ Test alerts with small thresholds first


ğŸš€ QUICK START (5 MINUTES)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Install: pip install memory-profiler pympler objgraph psutil

2. Under load, run: python memory_debug_toolkit.py detect 300 10

3. If "CRITICAL" or "HIGH" â†’ python memory_debug_toolkit.py scan-code ./app

4. Match patterns to table above, apply fix

5. Verify: Load test 30 minutes, monitor <1MB/min growth


ğŸ“š DOCUMENT CROSS-REFERENCES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

"Is this a memory leak?" 
  â†’ MEMORY_DEBUGGING_START_HERE.md > Decision Tree

"How do I use memory_debug_toolkit.py?"
  â†’ MEMORY_LEAK_DEBUGGING_GUIDE.md > Part 2: Debugging Workflow

"What's the exact code pattern I'm looking for?"
  â†’ MEMORY_LEAK_DEBUGGING_GUIDE.md > Part 4: Common Leak Patterns

"How do I setup Prometheus/Grafana?"
  â†’ OBSERVABILITY_METRICS.md > Monitoring Setup Examples

"What commands do I run on production?"
  â†’ MEMORY_LEAK_QUICK_REFERENCE.md > Production Commands

"How long will debugging take?"
  â†’ MEMORY_LEAK_DEBUGGING_GUIDE.md > Part 3: Debugging Checklist

"What if my app is stuck at Phase 2?"
  â†’ MEMORY_DEBUGGING_START_HERE.md > Troubleshooting


â±ï¸ TIME ESTIMATES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Scenario                           Detection  Location  Fix   Verify  Total
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Obvious endpoint leak               5 min     10 min   5 min  30 min  50 min
Unbounded cache pattern             10 min    20 min   5 min  30 min  65 min
Library/system leak                 15 min    45 min   1 hr   30 min  2-3 hrs
Complex (multiple endpoints)        20 min    60 min   30 min 60 min  2-3 hrs
Subtle timing issue                 30 min    2 hrs    var    var     varies


ğŸ“ KEY CONCEPTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

RSS (Resident Set Size)
  - Actual physical memory used by process
  - What you should monitor
  - Always check if growing monotonically

VMS (Virtual Memory Size)  
  - Total virtual address space allocated
  - Less useful for leak detection
  - Can include memory-mapped files

Monotonic Growth
  - RSS always increases, never decreases
  - Strong indicator of memory leak
  - Normal: RSS goes up/down as needed

Garbage Collection Slowdown
  - GC pause time increasing (>500ms p95)
  - Indicates too many objects in heap
  - Symptom of memory leak, not cause

Tracemalloc
  - Built-in Python memory tracking
  - Low overhead
  - Good for top-level allocations

Memory-profiler
  - Line-by-line memory usage
  - Higher overhead (5-50x slower)
  - Use for pinpointing exact lines


ğŸ“ SUPPORT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

For specific questions, consult:

Tool/Feature              Document                        Section
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Quick decision           MEMORY_DEBUGGING_START_HERE     Decision Tree
CLI commands            memory_debug_toolkit.py           --help
FastAPI integration     fastapi_memory_monitor.py        docstrings
Prometheus setup        OBSERVABILITY_METRICS.md         Monitoring Setup
Alert thresholds        OBSERVABILITY_METRICS.md         Alert Thresholds
Grafana dashboard       OBSERVABILITY_METRICS.md         Dashboard Setup
Common mistakes         MEMORY_LEAK_QUICK_REFERENCE.md  Common Mistakes
Pattern examples        MEMORY_LEAK_DEBUGGING_GUIDE.md  Part 5


âœ¨ WHAT MAKES THIS TOOLKIT PRODUCTION-READY
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ“ Zero code changes needed for initial detection (py-spy, toolkit)
âœ“ Optional 1-line FastAPI integration for detailed debugging
âœ“ Works in production without restarts (py-spy, dashboard endpoints)
âœ“ Prometheus metrics for alerting and trends
âœ“ 8 common leak patterns covered (90% of real-world leaks)
âœ“ Decision trees and runbooks for on-call engineers
âœ“ Regex patterns for log-based analysis (no code changes)
âœ“ Production-tested alert thresholds and queries
âœ“ Copy-paste fixes for each pattern
âœ“ Real-world scenarios with solutions


ğŸ“Š METRICS PROVIDED
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Via fastapi_memory_monitor.py:
  - process_rss_bytes              RSS in bytes (label: stage)
  - process_vms_bytes              Virtual memory in bytes
  - endpoint_memory_delta_bytes    Memory change per endpoint (histogram)
  - gc_duration_ms                 GC pause time (histogram by generation)
  - gc_collections_total           Total GC runs (counter)

Via debug endpoints:
  - Top memory allocations (tracemalloc)
  - Object type growth (objgraph)
  - Memory history (past N minutes)
  - GC statistics and status
  - Current process info (threads, FDs, CPU)
  - Leak detection verdict


ğŸ”’ SECURITY NOTES
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Debug Endpoints (/api/debug/memory/*)
  - Use only in development/staging
  - In production, wrap with authentication:
    @app.get("/api/debug/memory/snapshot")
    async def snapshot(auth: str = Header(...)):
        if not verify_debug_token(auth):
            raise HTTPException(401)
        ...

Prometheus Metrics Port (8001)
  - Use network policies to restrict access
  - Don't expose :8001 to internet
  - Kubernetes: NetworkPolicy or service mesh


ğŸ READY TO START
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Read:   MEMORY_DEBUGGING_START_HERE.md (5 min)
2. Setup:  pip install + setup_memory_monitoring(app)
3. Detect: python memory_debug_toolkit.py detect 300 10
4. Scan:   python memory_debug_toolkit.py scan-code ./app
5. Fix:    Apply pattern-specific fix
6. Verify: Load test 30 minutes

Questions? Check the document index above or specific sections.

Toolkit Version: 1.0
Created: 2025-11-24
For: Python 3.8+, FastAPI 0.95+
